import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Comparator;
import java.util.Objects;
import java.util.stream.Stream;
import javax.tools.JavaCompiler;
import org.apache.commons.lang3.exception.UncheckedException;

public class Main {
  private static final String CODE_TEXT =
      """
      import org.knowm.xchart.BitmapEncoder;
      import org.knowm.xchart.XYChart;
      import org.knowm.xchart.XYChartBuilder;

      public class MySupplierImpl implements MySupplier {
        public int numberOfSeries() {
          return 2; // Return the number of series to be generated
        }

        public String getTitle(int seriesIndex) {
          return "Series " + (seriesIndex + 1); // Return a title for each series
        }

        public double[][] generateSeries(int seriesIndex) {
          double[][] series = new double[10][2];
          double a = seriesIndex * 10; // Example coefficient based on series index
          for (int i = 0; i < series.length; i++) {
            double y = f(i, a);
            series[i][0] = i; // x value
            series[i][1] = y; // y value based on the function
          }
          return series;
        }

        private double f(double x, double a) {
          return x * x * a; // Example function
        }

        // Do not change this method, unless you know what you are doing.
        // It is used to plot the series generated by the methods above.
        public String plot() {
          XYChart chart =
              new XYChartBuilder()
                  .width(800)
                  .height(400)
                  .title("Area Chart")
                  .xAxisTitle("x")
                  .yAxisTitle("y")
                  .build();
          for (int i = 0; i < numberOfSeries(); i++) {
            double[][] series = generateSeries(i);
            double[] xData = new double[series.length];
            double[] yData = new double[series.length];
            for (int j = 0; j < series.length; j++) {
              xData[j] = series[j][0];
              yData[j] = series[j][1];
            }
            chart.addSeries(getTitle(i), xData, yData);
          }
          return MyPlotter.imgToBase64String(BitmapEncoder.getBufferedImage(chart));
        }
      }
      """;
  private static final String EMPTY_IMG_SRC =
      "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=";

  public static void main(String[] args) throws IOException {
    MyHttpServer.start(
        null,
        new MyHttpServer.MyHttpHandler(
            "/",
            exchange ->
                MyHttpServer.sendCustomResponse(
                    exchange,
                    200,
                    MyHttpServer.ContentType.HTML,
                    "templates/index.html",
                    CODE_TEXT,
                    EMPTY_IMG_SRC)),
        new MyHttpServer.MyHttpHandler(
            "/code",
            exchange -> {
              try {
                String codeText = MyHttpServer.getPathPart(exchange, 2);
                String imgSrc = compileSupplierCode(codeText).plot();
                MyHttpServer.sendCustomResponse(
                    exchange,
                    200,
                    MyHttpServer.ContentType.HTML,
                    "templates/index.html",
                    codeText,
                    imgSrc);
              } catch (Exception e) {
                throw new UncheckedException(e);
              }
            }));
  }

  private static MySupplier compileSupplierCode(String codeText) throws Exception {
    // Save the code to a temporary file and compile it
    Path parentDir = Paths.get("temp");
    if (!Files.exists(parentDir)) {
      Files.createDirectories(parentDir);
    }
    // Clean up the directory by deleting all files and subdirectories
    try (Stream<Path> paths = Files.walk(parentDir)) {
      paths.sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);
    }
    Files.createDirectories(parentDir);
    Path tempFile = Paths.get(parentDir.toString(), "MySupplierImpl.java");
    Files.writeString(tempFile, codeText);
    JavaCompiler jc = javax.tools.ToolProvider.getSystemJavaCompiler();
    jc.run(null, null, null, tempFile.toFile().getAbsolutePath());
    Path classFile = Objects.requireNonNull(tempFile.getParent()).resolve("MySupplierImpl.class");
    ClassLoader redefineClassLoader =
        new ClassLoader() {
          @Override
          public Class<?> loadClass(String name) throws ClassNotFoundException {
            if (name.equals("MySupplierImpl")) {
              try {
                byte[] buf = Files.readAllBytes(classFile);
                int len = buf.length;
                return defineClass(name, buf, 0, len);
              } catch (IOException e) {
                throw new ClassNotFoundException("", e);
              }
            }
            return getParent().loadClass(name);
          }
        };
    return (MySupplier)
        Class.forName("MySupplierImpl", true, redefineClassLoader)
            .getDeclaredConstructors()[0]
            .newInstance();
  }
}
