import com.sun.net.httpserver.HttpServer;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Objects;
import java.util.stream.Stream;
import javax.tools.JavaCompiler;

public class Main {
  private static final String CODE_TEXT =
      """
      import org.knowm.xchart.BitmapEncoder;
      import org.knowm.xchart.XYChart;
      import org.knowm.xchart.XYChartBuilder;

      public class MySupplierImpl implements MySupplier {
        public int numberOfSeries() {
          return 2; // Return the number of series to be generated
        }

        public String getTitle(int seriesIndex) {
          return "Series " + (seriesIndex + 1); // Return a title for each series
        }

        public double[][] generateSeries(int seriesIndex) {
          double[][] series = new double[10][2];
          double a = seriesIndex * 10; // Example coefficient based on series index
          for (int i = 0; i < series.length; i++) {
            double y = f(i, a);
            series[i][0] = i; // x value
            series[i][1] = y; // y value based on the function
          }
          return series;
        }

        private double f(double x, double a) {
          return x * x * a; // Example function
        }

        // Do not change this method, unless you know what you are doing.
        // It is used to plot the series generated by the methods above.
        public String plot() {
          XYChart chart =
              new XYChartBuilder()
                  .width(800)
                  .height(400)
                  .title("Area Chart")
                  .xAxisTitle("x")
                  .yAxisTitle("y")
                  .build();
          for (int i = 0; i < numberOfSeries(); i++) {
            double[][] series = generateSeries(i);
            double[] xData = new double[series.length];
            double[] yData = new double[series.length];
            for (int j = 0; j < series.length; j++) {
              xData[j] = series[j][0];
              yData[j] = series[j][1];
            }
            chart.addSeries(getTitle(i), xData, yData);
          }
          return MyPlotter.imgToBase64String(BitmapEncoder.getBufferedImage(chart));
        }
      }
      """;
  private static final String EMPTY_IMG_SRC =
      "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=";

  public static void main(String[] args) throws IOException {
    HttpServer server = HttpServer.create(new InetSocketAddress(80), 0);
    server.createContext(
        "/",
        exchange -> {
          System.out.println("Received request for / : " + exchange.getRequestURI());
          String response = getTemplate("index.html", CODE_TEXT, EMPTY_IMG_SRC);
          exchange.getResponseHeaders().add("Content-Type", "text/html; charset=UTF-8");
          exchange.sendResponseHeaders(200, response.length());
          OutputStream os = exchange.getResponseBody();
          os.write(response.getBytes(StandardCharsets.UTF_8));
          os.close();
        });
    server.createContext(
        "/code",
        exchange -> {
          System.out.println("Received request for /code : " + exchange.getRequestURI());
          try {
            String codeText =
                URLDecoder.decode(
                    exchange.getRequestURI().toString().substring(6), StandardCharsets.UTF_8);
            String imgSrc = compileSupplierCode(codeText).plot();
            String response = getTemplate("index.html", codeText, imgSrc);
            exchange.getResponseHeaders().add("Content-Type", "text/html; charset=UTF-8");
            exchange.sendResponseHeaders(200, response.length());
            OutputStream os = exchange.getResponseBody();
            os.write(response.getBytes(StandardCharsets.UTF_8));
            os.close();
          } catch (Exception e) {
            String errorResponse =
                String.format(
                    "Error compiling code: %s%n%n%s",
                    e.getMessage(), Arrays.toString(e.getStackTrace()));
            exchange.getResponseHeaders().add("Content-Type", "text/plain; charset=UTF-8");
            exchange.sendResponseHeaders(500, errorResponse.length());
            OutputStream os = exchange.getResponseBody();
            os.write(errorResponse.getBytes(StandardCharsets.UTF_8));
            os.close();
          }
        });
    server.setExecutor(null); // creates a default executor
    server.start();
  }

  private static String getTemplate(String name, String codetext, String imgsrc)
      throws IOException {
    try (InputStream templateStream = Main.class.getResourceAsStream("templates/" + name)) {
      assert templateStream != null;
      String template = new String(templateStream.readAllBytes(), StandardCharsets.UTF_8);
      return template.replace("{{codetext}}", codetext).replace("{{imgsrc}}", imgsrc);
    }
  }

  private static MySupplier compileSupplierCode(String codeText) throws Exception {
    // Save the code to a temporary file and compile it
    Path parentDir = Paths.get("temp");
    if (!Files.exists(parentDir)) {
      Files.createDirectories(parentDir);
    }
    // Clean up the directory by deleting all files and subdirectories
    try (Stream<Path> paths = Files.walk(parentDir)) {
      paths.sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);
    }
    Files.createDirectories(parentDir);
    Path tempFile = Paths.get(parentDir.toString(), "MySupplierImpl.java");
    Files.writeString(tempFile, codeText);
    JavaCompiler jc = javax.tools.ToolProvider.getSystemJavaCompiler();
    jc.run(null, null, null, tempFile.toFile().getAbsolutePath());
    Path classFile = Objects.requireNonNull(tempFile.getParent()).resolve("MySupplierImpl.class");
    ClassLoader redefineClassLoader =
        new ClassLoader() {
          @Override
          public Class<?> loadClass(String name) throws ClassNotFoundException {
            if (name.equals("MySupplierImpl")) {
              try {
                byte[] buf = Files.readAllBytes(classFile);
                int len = buf.length;
                return defineClass(name, buf, 0, len);
              } catch (IOException e) {
                throw new ClassNotFoundException("", e);
              }
            }
            return getParent().loadClass(name);
          }
        };
    return (MySupplier)
        Class.forName("MySupplierImpl", true, redefineClassLoader)
            .getDeclaredConstructors()[0]
            .newInstance();
  }
}
