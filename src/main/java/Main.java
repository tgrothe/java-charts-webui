import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpServer;
import java.io.*;
import java.net.InetSocketAddress;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Stream;
import javax.tools.JavaCompiler;
import org.apache.commons.text.StringSubstitutor;

public class Main {
  private static final String CODE_TEXT =
      """
      import org.knowm.xchart.BitmapEncoder;
      import org.knowm.xchart.XYChart;
      import org.knowm.xchart.XYChartBuilder;

      public class MySupplierImpl implements MySupplier {
        public int numberOfSeries() {
          return 2; // Return the number of series to be generated
        }

        public String getTitle(int seriesIndex) {
          return "Series " + (seriesIndex + 1); // Return a title for each series
        }

        public double[][] generateSeries(int seriesIndex) {
          double[][] series = new double[10][2];
          double a = seriesIndex * 10; // Example coefficient based on series index
          for (int i = 0; i < series.length; i++) {
            double y = f(i, a);
            series[i][0] = i; // x value
            series[i][1] = y; // y value based on the function
          }
          return series;
        }

        private double f(double x, double a) {
          return x * x * a; // Example function
        }

        // Do not change this method, unless you know what you are doing.
        // It is used to plot the series generated by the methods above.
        public String plot() {
          XYChart chart =
              new XYChartBuilder()
                  .width(800)
                  .height(400)
                  .title("Area Chart")
                  .xAxisTitle("x")
                  .yAxisTitle("y")
                  .build();
          for (int i = 0; i < numberOfSeries(); i++) {
            double[][] series = generateSeries(i);
            double[] xData = new double[series.length];
            double[] yData = new double[series.length];
            for (int j = 0; j < series.length; j++) {
              xData[j] = series[j][0];
              yData[j] = series[j][1];
            }
            chart.addSeries(getTitle(i), xData, yData);
          }
          return MyPlotter.imgToBase64String(BitmapEncoder.getBufferedImage(chart));
        }
      }
      """;
  private static final String EMPTY_IMG_SRC =
      "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=";
  private static final HashMap<String, String> templates = new HashMap<>();

  public static void main(String[] args) throws IOException {
    HttpServer server = HttpServer.create(new InetSocketAddress(80), 0);
    server.createContext(
        "/",
        exchange -> {
          System.out.println("Received request for /: " + exchange.getRequestURI());
          try {
            String response = getTemplate("templates/index.html", CODE_TEXT, EMPTY_IMG_SRC);
            exchange.getResponseHeaders().add("Content-Type", "text/html; charset=UTF-8");
            exchange.sendResponseHeaders(200, response.length());
            OutputStream os = exchange.getResponseBody();
            os.write(response.getBytes(StandardCharsets.UTF_8));
            os.close();
          } catch (Exception e) {
            handleException(exchange, e);
          }
        });
    server.createContext(
        "/code",
        exchange -> {
          System.out.println("Received request for /code: " + exchange.getRequestURI());
          try {
            String codeText =
                URLDecoder.decode(
                    exchange.getRequestURI().toString().substring(6), StandardCharsets.UTF_8);
            String imgSrc = compileSupplierCode(codeText).plot();
            String response = getTemplate("templates/index.html", codeText, imgSrc);
            exchange.getResponseHeaders().add("Content-Type", "text/html; charset=UTF-8");
            exchange.sendResponseHeaders(200, response.length());
            OutputStream os = exchange.getResponseBody();
            os.write(response.getBytes(StandardCharsets.UTF_8));
            os.close();
          } catch (Exception e) {
            handleException(exchange, e);
          }
        });
    server.setExecutor(null); // creates a default executor
    server.start();
  }

  private static void handleException(HttpExchange exchange, Exception e) throws IOException {
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    e.printStackTrace(pw);
    String sStackTrace = sw.toString();
    exchange.getResponseHeaders().add("Content-Type", "text/plain; charset=UTF-8");
    exchange.sendResponseHeaders(500, sStackTrace.length());
    OutputStream os = exchange.getResponseBody();
    os.write(sStackTrace.getBytes(StandardCharsets.UTF_8));
    os.close();
  }

  private static String getTemplate(String path, String... args) throws IOException {
    if (!templates.containsKey(path)) {
      try (InputStream templateStream = Main.class.getResourceAsStream(path)) {
        assert templateStream != null;
        templates.put(path, new String(templateStream.readAllBytes(), StandardCharsets.UTF_8));
      }
    }
    AtomicInteger ai = new AtomicInteger(0);
    return StringSubstitutor.replace(
        templates.get(path),
        Arrays.stream(args)
            .reduce(
                new HashMap<>(),
                (map, element) -> {
                  map.put(ai.getAndIncrement() + "", element);
                  return map;
                },
                (map1, map2) -> {
                  map1.putAll(map2);
                  return map1;
                }),
        "{{",
        "}}");
  }

  private static MySupplier compileSupplierCode(String codeText) throws Exception {
    // Save the code to a temporary file and compile it
    Path parentDir = Paths.get("temp");
    if (!Files.exists(parentDir)) {
      Files.createDirectories(parentDir);
    }
    // Clean up the directory by deleting all files and subdirectories
    try (Stream<Path> paths = Files.walk(parentDir)) {
      paths.sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);
    }
    Files.createDirectories(parentDir);
    Path tempFile = Paths.get(parentDir.toString(), "MySupplierImpl.java");
    Files.writeString(tempFile, codeText);
    JavaCompiler jc = javax.tools.ToolProvider.getSystemJavaCompiler();
    jc.run(null, null, null, tempFile.toFile().getAbsolutePath());
    Path classFile = Objects.requireNonNull(tempFile.getParent()).resolve("MySupplierImpl.class");
    ClassLoader redefineClassLoader =
        new ClassLoader() {
          @Override
          public Class<?> loadClass(String name) throws ClassNotFoundException {
            if (name.equals("MySupplierImpl")) {
              try {
                byte[] buf = Files.readAllBytes(classFile);
                int len = buf.length;
                return defineClass(name, buf, 0, len);
              } catch (IOException e) {
                throw new ClassNotFoundException("", e);
              }
            }
            return getParent().loadClass(name);
          }
        };
    return (MySupplier)
        Class.forName("MySupplierImpl", true, redefineClassLoader)
            .getDeclaredConstructors()[0]
            .newInstance();
  }
}
